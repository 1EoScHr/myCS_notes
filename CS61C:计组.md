# CS61C 计算机体系结构
学习整个系统从上到下是如何工作的，从**顶层——最高抽象层**一直到电流流动和电子填补空穴的硬件底层。  

***

## P1_Intro

### 内容

1. 理解计算机结构
2. 计组的伟大思想
3. 

#### 计算机结构

#### 计组伟大思想

+ 抽象
+ 摩尔定律
+ 局部性原则/内存层次结构
+ 并行性
+ 性能测量/改进反馈
+ 可靠性与冗余性

以上是CS61C的，黑皮书上有另外一种，~~学习按上面，备考按下面~~：  

+ 使用抽象简化设计
+ 加速大概率事件
+ 通过并行提高性能
+ 通过流水线提高性能
+ 通过预测提高性能
+ 存储层次
+ 通过冗余提高安全性

**理解：**   
1. 抽象创造出简化的接口，从而使上层不必对下层理解就可使用下层。如下面的内存层次，通过抽象的视角设计，实现了感知上类似于无穷大无穷快。  
2. 集成电路上晶体管的数量按照每年增长一定倍率，尽管近年来有所下降。摩尔定律带来的红利为每年都会有更优秀的处理器来运行之前的糟糕程序，使得对应用不重视，但随着速度放缓，开发专用计算机就有了用  
3. 从寄存器、cache、内存、硬盘到输出是很漫长的，在宏观视角来看就类似于家、学校、附近城市、其他星球、其他星系等
4. 并行、多线程提高某些部分的效率，但是由阿姆达尔定律，对部分进行优化，即使到极限也还有短板 
5. 略，理解还没到  
6. 正如宇宙粒子撞击，如果随机的一个bit变化，可能会造成不好的后果，比如银行，自动驾驶。为防止这样，为提高可靠，使用冗余设计  

***

## P2_Number_Representations

### 数据的输入：Analog->Digital

现实世界是模拟的，但要转换成数字形式计算机才能处理和操作他们。  

#### 方法-两件事：时间离散化与数值离散化  
1. 采样（Sample）  
	每个时间点询问一次数值，通常是固定时间间隔  
2. 量化（Quantize）  
	获得的数据可能是一个小数，从存储角度看仍然属于“连续”，因此规定一系列的标尺，将其量化  

~~此事在《信号与系统分析》中也有记载~~  

#### 但是数字数据不一定必须从模拟数据中来
比如纯数字世界生成的概念图片


### 本讲核心理念：比特可以代表任何事物

1. 字符  
	**7bit**可以组成**ASCLL**码，英文足够；还有8、16、32位的Unicode存储所有语言、所有符号  
2. 逻辑值  
	通常0假1真  
3. 颜色  
	RGB-00、01、11  
4. and others
	任何能够列举的事物，都可以指定比特表示规律，并将其数字化。
	
***N位可以表示2的N次方种事物***  


### 二进制、八进制、十进制、十六进制

幽默笑话：人类遇到了外星人，大家都用的基数"10"(幺零)  
相互转换，老生常谈了  

### 数字表示法
正数无所谓  
负数：没有免费的午餐（Ain't no free lunch），牺牲原本能表示的最大的来换取负数，但正数会溢出到0到负数  
反码：直接取反，如+7为00111，-7为11000，同样的正书会溢出到最负数，方向对了，但有重叠（两个0）  
**补码**：那么只要将下面负数部分向左平移一下就可，在补码中，全1为-1。补码负转正只要翻转位+1。这样没有重叠，方向一致，负数比正数多一个  
**偏置编码**：有一组非负数，想要将其钳制成在“0”上下，则可以使用偏置码，比如五位二进制时**减15（2^5-1）**，这样从00000到11111就是一个纯粹的上升顺序，只有一个0，正数比负数多1。其过程为：得到一些正负值-->转换为无符号值-->应用偏置解码为原本有符号值  

***因此最常用的编码方式：无符号，补码，偏置码bias，在C中分别为uintx_t、intx_t、手动实现（类似通信协议）***

***

## P3_C_Intro 

ENIAC（第一台），EDSAC（存储程式）  

### Why C?
在计组这门课中，更倾向利用**底层架构的特性**，C更接近于硅片，能够操作位，实现更多的**控制**。***在语言抽象层次中越往上走，你在编程中放弃的控制权就越多，但C足够底层，让你明确知道自己在做什么，***（~~CS106L亦有提到~~）  

### 编译vs解释
**C编译后**，所得到的是基于所构建的特定架构，而不能在不同机器上直接用  
**Java编译后**，得到的是**架构独立性**的字节码，可以传递给不同机器并直接运行  
**Python则是被解释的**  

#### C Pre-Processor(CPP) 预编译

**预编译命令**：任何以“**#**”开头的都是C预处理器的命令，生成.**i**文件  
+ "\#include"会提出里面的.h文件并将其放入.i文件中，是直接插入，而非引用等，同样的，使用尖括号也做同样的事，只不过是从标准库的位置抓取  
+ "\#define"宏定义，一般要在周围加括号，有时会使阅读性下降，因为是文本替换，也会造成重复引用  


	#define min (X,Y) ((X)<(Y)?(X):(Y))  
	next = min(w, foo(z))  
	next = ((w)<(foo(z)?(w):(foo(z)))  

	
+ "#if/#endif"条件编译  


#### C的编译：隐藏的两步
1. 由.**c**编译为.**o**，这是将其编译为**汇编语言**  
2. 然后将这些与库**链接**，形成**可执行文件**  

由此，当用**Makefile**时，只更改一个.c，那么只用更新一个.o，剩下的没有变，依然可以**链接**，而不需要重新编译所有文件，***这也是为什么大项目要分成多个文件***。

#### 编译的缺点
1. 验证功能时必须**依赖于特定代码**  
2. .o文件与可执行文件都是**基于特定机器的**，移植性不好，需要重新编译  
3. 尽管编译阶段可以并行(make -j)，但在**链接阶段的串行**很慢，体现了阿姆达尔定律  

### C vs Java

+ **核心理念**：**C**-函数，**Java**-抽象数据类型（类、抽象数据概念）  
+ **编译方式**：Java C生成独立于机器的字节码，C生成机器语言代码（依赖于机器的代码），同时也要Gcc -O xx xx.c  
+ 在Uinx中，表示成功一般是“0”，因为成功只有一种，而失败有好多种，其他任何一个数字都有可能  
+ **内存管理**：C要自己来控制，而Java有完善的垃圾管理机制  
+ **注释**：基本一致  
+ **常量**：C一般用\#define或const，Java用final  
+ **命名约定**   
+ **导入库**：C用\#来包括，用尖括号或引号，Java导入模块  
+ **运算符**  

#### 从ANSI C升级
1. 变量不必在开头申请  
2. 注释写法  
3. int升级为int类型，明确指出需要多少位  
4. 标准的布尔类型  
5. 多线程支持，unicode升级，gets修复  

### C 语法
略  

### 错误与指针

+ **变量的初始化**：变量定义后需要给定一个**初始值**，否则就是**垃圾值**  
+ **未定义行为**：Heisenbugs  
+ **地址VS值**  
+ **指针危险**：没有初始化  

### 指针与结构体
点引用与箭头引用
错误类型：段错误，没有权限访问内存，总线错误，没有对齐  

## P4_C_Memory_Management

### 常用函数

+ **sizeof**()  
	返回以字节记的类型大小。
+ **malloc()**  
	接受需要的字节数，返回一个指向**未初始化**空间的指针（void*）。  
+ **realloc(ptr, n\*sizeof(type))**  
	重新申请内存，接受两个参数，将第一个参数指向的内容搬运到第二个参数大小的内存，释放ptr指向的旧区域，并返回指向新区域的指针。  
+ **free(ptr)**  
	接受一个指针，将其内存释放。要注意不能释放一块内存两次，同时也不能释放不是由malloc申请来的内存（例如申请的数组，指针向后移动，那么就不能释放，只有在原位置才能）  

	
### 内存申请

+ 动态申请内存格式：  
	1. ptr = (type\*)malloc(n*sizeof(type))  
	申请指向一块内存空间的通用指针，空间大小为type的大小，将指针转成特地用于type的指针并将其赋予ptr。  
	2. ptr = (type\*)realloc(ptr, m*sizeof(type))  
	当感觉malloc分配的内存不够用时，可以进行重新分配。  
	2. if (ptr == NULL)  
	当系统内存不足时，malloc、realloc返回值为NULL，如果不进行判断，会对空指针进行操作，所以要判断，并进行处理。  
+ 内存泄露：  
	通常在之程序结束后会自动将所有申请的内存释放掉，但是如果申请的内存过多，或者将主程序的功能包装成子程序后没有进行释放，都会导致泄露严重，造成严重后果。  
	
### C语言的内存管理

#### 内存池
+ **Static storage 静态存储**  
	全局变量（虽然在静态存储，但其实仍然可以更改其值）存储于此，其大小是固定的，不会在程序运行时变化  
+ **Stack 栈**  
	局部变量、参数、返回地址等都在栈中存储  
	栈内存与栈数据结构相似  
+ **Heap 堆**  
	malloc等动态分配的东西在堆里存储  
	堆内存与对数据结构完全不同，就是一堆内存  
	
#### 程序运行时内存结构
![](pictures/计组/memory.png)  
+ 栈内存从内存最高处往下增减  
+ 最底层是代码与静态内存，它们的大小不变  
+ 堆内存从静态内存往上增长  
+ 相较于栈内存，其对于故障的弹性更好，譬如当内存不足时，调用栈内存（比如double ar\[100000\]），加载到栈上的临时变量会导致崩溃。而若是malloc一个大内存，若是没有能力，可以返回NULL。  
+ 返回栈时，并没有进行清零，只是栈指针上移，设立了不能访问的“禁区”，而东西确实还存在。  

#### 手动/自动管理
+ **堆内存**管理  
	内存有一种管理**空闲内存块**的数据结构，是一种**环链表**，存着每一个空闲内存块的头。  
	当malloc一块内存，会遍历这个循环链表，找到一个合适的block，因此malloc执行速度慢，因为除了本身栈中函数调用的开销外，还有内部遍历的过程。在选择块时有几种策略，最适合、首次匹配、next匹配  
	而free则会将碎片的堆内存整合起来。  
	
### 当内存go bad时

指针丢失、内存泄漏、数组越界等糟糕的情况时常发生  

+ 返回栈地址，返回后虽然不会销毁，但别的栈帧调用后会变成垃圾值  
+ free后仍继续调用，不知道  
+ realloc移动数据后，仍然使用过时指针  
+ free错地址，譬如申请的地址指针自己移动  
+ 重复free  
+ 丢失初始指针  

**解决办法**：Valgrind，分析静态代码。