# CS50P:Python速通

针对python本身进行比较系统的速通学习，以便后面的CV、机器学习、深度学习等

***

## Week0 Functions,Varibles

函数(参数)  
函数的"**副作用side effects**"，非贬义，而是指伴随函数的打印、音频等  
**input函数**会输出其中的参数，并接受一个参数，其返回的是字符串，可能需要额外转换  
**注释**：井号#（一行），三引号"""（包围），计算机会自动忽视  
伪代码：pseudocode  
**print函数**：  
	通过‘+’来连接多个变量，例如`print("fku " + name)`，直接连接，不会加空格  
	‘,’同样可以一起，例如`print("fku", name)`，这个会在变量之间加空格  
	有种新特性称为f字符串，便利的掺杂：`print(f"fku {name}")`，同样的`print(f"{z:,}")`（会按英美方式格式化），`print("f{z:.2f}")`（会输出截止2位）  
	对于输出引号"的边缘情况，可以使用反斜杠转义  
	原型print(*objects, sep=' ', end='\n', file=sys.stdout, flush-False)  ，*objects意味可以接受任意多个参数，sep为参数之间的，end为调用结束后的，可以自行覆盖默认参数。  
**str这一类型**拥有许多方法，例如`str.strip()`会返回str去除两侧空格与换行符等的结果，`str.capitalize()`会返回字符串大写，`str.title()`会像标题一样将每个单词置大写，`str.split(" ")`会将str按“ ”分割并返回，这些方法可以嵌套调用（只要返回类型不变）  
使用什么标准无所谓，但是要说，喂，为什么这样用，有什么好处？  
直接命令行用python可以进入**交互模式**  
浮点数可以用`round`函数，原型为`round(number[, ndigits])`，输入number，将其在第ndigits位进行四舍五入  
**自定义函数使用def**进行，可以添加默认参数，记得缩进；此外还有**编码技巧**：平时需要将调用的函数都定义在最上方，但影响了逻辑，可以先定义一个main()（这里其实叫什么都一样，与c不同）作为"主函数"，其下定义其他函数，最下方调用main()即可。注意作用域。可以使用return。  
n \*\* 3表示 n的三次方  

***

## Week1 条件句

if下方也要加**缩进**  
**布尔类型**：True与False
条件判断有**if**、**elif**、**else**、**or**、**and**、**match**等  
写条件句时要注意让其更简洁、逻辑清晰  
python可以写出`80 <= score < 90`这样的双向条件代码，`return True if n % 2 == 0 else False`也是python的特有形式   
python的“match”语句类似于switch,并且其中的`case _：`与default相同  
case中用 |，而if中用or来连接  

***

## Week2 Loops

while、for、continue、break  
**list**类型，用方括号[]表示  
**dict**类型，用于将不同类型关联起来(key & value)，用大括号{}来表示，相当于列表的索引不再是数字，调用要用[]  
**range()**函数，输入的第一个参数，从0开始到小于它，如`range(3)`实际上是0、1、2  
**len()**函数，输入一个列表，返回列表的长度  
for循环与range有一种“**Pythonic**”的写法：`for _ in range(3)`，能够忽略循环中循环变量的名字，而只关注于循环的特性；然而当循环变量本身有作用、而不是单纯计数，就要清晰表示：`for student in students`，students为字符串列表  
可以字面上的**乘法**来输出一个字段多次：`print("meow\n" * 3)`  
可以使用无限循环(while True:)限制用户  
None表示缺失  

***

## Week3 Exceptions 异常

**异常分类**：  
+ SyntaxError：语法错误  
+ ValueError：数值错误，输入的值不正确等  
+ NameError：名称错误，变量未定义时引用等  
+ KeyError：索引错误，新元素引入等  
+ EOFError：文件结束错误，用于ctrl+d来结束连续输出等  

**流程**：  
+ **try**：要测试的代码  
+ **except**：加上预期的错误类型，捕捉错误，进行错误处理  
+ **else**：若没有出问题执行这个  
+ **pass**：可以用作占位，譬如except了错误，但不想处理，pass；if了条件不想处理，pass等  

**手动抛错误**：  
+ 使用**rasie(错误类型)**来手动制造错误类型  

***

## Week4 Libraries 资源库

库就是模块化（modules）的代码  
使用**import**关键字从某个库中加载函数，引入的函数必须要与其作用域相关联，如`import random`后只能`random.choice(seq)`  
使用**from**关键字从一个库中导入函数，但比import更具体，如`from random import choice`后可以直接`choice()`，因为相当于直接导入进命名空间，可以简化代码，前提是命名不会冲突  

第三方的代码库称为包（packages）（包在python的严格意义是由一个文件夹实现的），可以安装，来获得其他人实现的更强大的代码，有一个有名的cowsay包，可以用cow画奶牛说话，trex画霸王龙说话  
包通常需要管理，这就有了**包管理器**（**pip**）  

API安装，API这里指代python文件和函数，如r**equests**库，访问互联网：  		
+ requests.get()，访问URL并获取信息

python也自带json库，可以简化、解析获取的json信息：  
+ json.dumps()  

python自带一整套模块，包括随机库(radom.py)，其中有：  
+ choice(seq)，等概率返回seq中的随机一元素  
+ randint(a,b)，等概率返回包括a、b的中间一元素  
+ shuffle(x)，接受一个列表并将其打乱，直接修改自身  
还包含一个统计库(statistics.py)，其中有：  
+ mean()，返回平均值  
还有命令行参数特性，能够访问在命令行中输入的值，在系统库(sys.py)中:  
+ argv，是命令行中输入的所有参数的列表，第0个元素是程序名，后面的是各个输入参数  
+ exit(s)，打印s并立刻停止函数  

在列表中，**slices**为切片列表，即取列表的子集，例如`sys.argv[1:]`就是从列表的1号索引元素到最后的切片，而`sys.argv[1:-1]`就是索引为1的元素到倒数第二个元素的切片，因为**包括开头元素但不包括结尾元素**（列表索引为负时，-1为最后一个元素，以此类推）  

创建自己的库：  
在定义时沿用main，会在其他地方重新引用时整个再运行，因此要用：`if __name__ = "__main__"`:  
**__name__**：特殊变量，当在当前文件使用时，由python自动设置为"__main__"，而当作模块被调用时就不会。所以就应该将main函数加载这个条件下以使用。  

***

## Week5 Unit Tests 单元测试

可能过去一直通过运行程序来测试代码again and again，但是，要尽早养成测试自己的代码的习惯，而不是等到代码很多时才整个测试程序。  
再次强调养成main函数不是总被调用的习惯，即`if __name__ = "__main__":`  
**assert**关键字：允许做exactly that，**断言**某件事，当其为真时无事发生，为假时抛出错误信息以及asserterror。  
测试时凭借自己的经验判断潜在的边缘条件  
**测试工具：pytest**：  
+ 写法:  
	1. import待测试的模块/函数  
	2. 对于**值类型**，定义一或多个测试函数（这样测试的覆盖面广，如果全部放在一个里面，会被一个错误阻塞），里面全放断言即可，不用try、except,也不用加主函数等  
	3. 对于**捕捉错误类型**，可以在测试函数import pytest，然后再with pytest.raises(错误类型):，在下面放例子  
+ 其会输出是否正确以及错误信息  
+ 还可以测试**一整个包package**，为例则是在目录下增加一个"__init__.py"文件来告诉python这是一个包，然后`pytest 目录`，这样就会搜寻目录中所有的可用的测试案例进行测试  
**一些思路**：  
为了方便测试，可以将输出信息返回主函数进行输出，这样便于捕捉返回值来测试  

***

## Week6 File I/O 文件输入/输出

目前的程序仅仅将变量、数据存放在**内存**中，也就是程序一退出，数据都会**消失**。研究如何保存一些文件，从而使数据**持久保存**。  

回归**list类型**，可以存储不止一条信息，但是数据都在内存里，程序退出即会消失。使用".append()"方法可以将新元素添加到列表  

**open()函数**：可以打开一个文件，然后从中**读取**或**写入**信息  
其第一个参数为**文件名**，第二个参数是**w、r、a”**，为w时会重新创建文件，相当于新内容**覆盖**，为a时会在文件尾部追加，为r或不加参数会进入只读模式  
返回一个文件句柄  

**sorted()函数**，返回对参数（列表、字典、文件等可迭代类型）进行字典排序的结果，想要进行**反向排序**可以将reverse参数置True，想要指定**键排序**就将key参数设为想要指定的键。  
一般想要以某种方式更改数据（如排序），就在顶部创建空列表，向其中追加以将数据集中，最后对列表进行统一处理  

**with关键字**：有时我们可能会忘记关闭文件，使用这个关键字可以在指定的上下文内**打开并自动关闭**某些文件，写法为`with open("xxx", "a") as file:`，当下方不再缩进时就会自动关闭  

**文件句柄**：  
+ ".write()"，将参数**写**进文件  
+ ".close()"，**关闭**并有效保存文件  
+ ".readlines()"，读取文件的**所有行**，并将其作为一个**列表**返回  
对于遍历文件中所有行，有一种**更高效**的方法：`for line in file:`  

**csv文件**，以逗号分割，相当于二维数据，通过split方法将一行断开就能使用  
split方法还有很好的**特性**，放多个变量来接，但当数量对不上就会ValueError，譬如某一个值内部有逗号分割——事情变**复杂**得很快。  
其实，python有自己的**csv库**，能够解决这些问题。   

**CSV库**：  
+ **csv.reader**()：输入文件句柄，其会将csv中的分隔符、换行符等的边界条件等进行自动解析，返回一个包含csv每一行的列表  
+ **csv.DictReader**()：输入文件句柄，将文件从顶到底进行迭代，加载每行文本，最后作为一个**存放字典的列表**，而不是作为列的列表，前提是CSV文件要有一个头，这样使得代码更加健壮  
譬如一份包含姓名、学院信息的CSV文件，**reader**会返回一个列表，列表的每一项里面是["某某某", "HC"]；而**DictReade**也会返回一个列表，但每一项是一个字典，里面是{"姓名":“某某某”， “学院”："HC"}  
+ **csv.writer**()：接受文件变量，返回一个writer类型，writer的方法：  
	+ **writer.writerow()**，参数为一个列表，是要写进一行的内容  
+ **csv.DictWriter**()：同样的，是一个字典写入writer，在有表头时用。其有**两个参数**，第一个参数为文件，第二个参数为"fieldnames"，相当于告诉python都有哪些列将会被写入。方法为：  
	+ **writer.writerow()**，参数为一个字典，也是要写入的对应内容  

**PIL库**：pillow库是一个**图像文件处理库**，可以用来做gif：  
+ 导入PIL库中的Image函数、建立一个空列表images，后面用来放gif的每一帧、用Image.open()打开图像文件，返回一个图像句柄、将图像append进列表内、循环、用images[0].save()方法自动保存并关闭，道理是保存第一张，但将其他加在第一张上，暂停时间、无限循环、保存路径等  
+ `from PIL import Image, ImageOps`：  
	+ Image.open(path):打开文件，返回一个Iamge类型 
	+ .size:返回Image类型的图片长宽  
	+ ImageOps.fit(Image,size)，调整Image类型的大小，返回调整结果  
	+ .paste(Image, 掩码)，将Image覆盖到调用类型上，并只在掩码图像区域内覆盖  
	+ .save(path)，将Image类型保存至指定路径

**函数作为参数传递给其他函数**：  
正如sorted()的对字典操作，假如有一个字典名为student，有name与house两个键，想要按名字进行排序，可以用`sorted()`来进行排序，其会自动调用key等于的函数：  
	
	def get_name():  
		return student["name"]  
	for student in sorted(students, key=get_name):  
		...  

正如某些不严格必要的变量可以省略，函数也可以用一个**匿名函数**来表示：  
`for student in sorted(student, key=lambda student:student["name"])`  
更一般的，匿名函数可以在多个地方定义并调用，其可以有多个输入参数，用逗号分隔。











